/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package proxy

import (
	"context"
	"errors"
	"fmt"
	"log"
	"os"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	emulatorConfig "github.com/detiber/k8s-jumperless/utils/internal/emulator/config"
	"github.com/detiber/k8s-jumperless/utils/internal/proxy"
	"github.com/detiber/k8s-jumperless/utils/internal/proxy/config"
)

func NewProxyCommand(v *viper.Viper, parentLogger *log.Logger,
	defaultConfigFile, configFileFlagName string) *cobra.Command {
	logger := log.New(parentLogger.Writer(), parentLogger.Prefix()+" [proxy]", parentLogger.Flags())

	cmd := &cobra.Command{
		Use:   "proxy",
		Short: "Jumperless proxy",
		Long:  `A proxy sends configured commands to a Jumperless device over a serial port`,
		RunE: func(cmd *cobra.Command, _ []string) error {
			ctx := cmd.Context()

			configFile, err := findConfigFile(cmd, v, configFileFlagName, defaultConfigFile)
			if err != nil {
				return fmt.Errorf("failed to determine config file: %w", err)
			}

			proxyConfig := config.NewFromViper(v)
			emuConfig := emulatorConfig.NewFromViper(v)

			recording, err := runProxy(ctx, logger, proxyConfig)
			if err != nil {
				return err
			}

			return saveRecording(logger, proxyConfig, emuConfig, configFile, recording)
		},
	}

	// Command-line flags
	cmd.Flags().Int(config.FlagBufferSize, config.DefaultBufferSize, "buffer size for reading from the real serial port")
	_ = v.BindPFlag(config.ViperBufferSize, cmd.Flags().Lookup(config.FlagBufferSize))

	cmd.Flags().String(config.FlagVirtualPort, "",
		"symlink for virtual serial port(if not specified, it will use the autogenerated virtual port)")
	_ = v.BindPFlag(config.ViperVirtualPort, cmd.Flags().Lookup(config.FlagVirtualPort))

	cmd.Flags().String(config.FlagRealPort, "",
		"real serial port to use (if not specified, will attempt to auto-detect)")
	_ = v.BindPFlag(config.ViperRealPort, cmd.Flags().Lookup(config.FlagRealPort))

	cmd.Flags().Int(config.FlagBaudRate, config.DefaultBaudRate, "baud rate for the real serial port")
	_ = v.BindPFlag(config.ViperBaudRate, cmd.Flags().Lookup(config.FlagBaudRate))

	cmd.Flags().Bool(config.FlagOverwrite, false, "overwrite existing emulator mappings instead of appending")
	_ = v.BindPFlag(config.ViperOverwrite, cmd.Flags().Lookup(config.FlagOverwrite))

	return cmd
}

func runProxy(ctx context.Context, logger *log.Logger,
	proxyConfig *config.ProxyConfig) (emulatorConfig.Mappings, error) {
	logger.Printf("Starting Jumperless proxy with config: %+v", proxyConfig)

	// Create proxy
	p, err := proxy.New(proxyConfig, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to create proxy: %w", err)
	}

	recording, err := p.Run(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to run proxy: %w", err)
	}

	logger.Printf("proxy stopped")

	return recording, nil
}

func findConfigFile(cmd *cobra.Command, v *viper.Viper, configFileFlagName, defaultConfigFile string) (string, error) {
	// Try to get config file from viper
	configFile := v.ConfigFileUsed()
	if configFile != "" {
		return configFile, nil
	}

	configFile, err := cmd.Flags().GetString(configFileFlagName)
	if err != nil {
		return "", fmt.Errorf("failed to get config file from flag: %w", err)
	}

	if configFile != "" {
		return configFile, nil
	}

	// Use default config file
	return defaultConfigFile, nil
}

func saveRecording(logger *log.Logger, proxyConfig *config.ProxyConfig,
	emuConfig *emulatorConfig.EmulatorConfig, configFile string,
	recording emulatorConfig.Mappings) error {
	if len(recording) == 0 {
		logger.Printf("No requests/responses recorded")
		return nil
	}

	// Save recording
	switch {
	case proxyConfig.Overwrite:
		logger.Printf(
			"Overwriting existing emulator mappings and saving %d recorded request/response pairs to emulator config",
			len(recording),
		)

		emuConfig.Mappings = recording
	case len(emuConfig.Mappings) == 0:
		logger.Printf(
			"No existing emulator mappings, saving %d recorded request/response pairs to emulator config",
			len(recording),
		)

		emuConfig.Mappings = recording
	default:
		logger.Printf(
			"Existing emulator mappings, appending %d recorded request/response pairs to emulator config",
			len(recording),
		)

		for _, r := range recording {
			emuConfig.Mappings.AddResponse(r.Request, r.Responses...)
		}
	}

	// We only want to update the mappings in the config file, so create a new viper instance
	// to avoid writing other config values
	v := viper.New()
	v.SetConfigFile(configFile)
	v.SetConfigType("yaml")

	var viperNotFoundErr viper.ConfigFileNotFoundError
	if err := v.ReadInConfig(); err != nil && !errors.As(err, &viperNotFoundErr) && !errors.Is(err, os.ErrNotExist) {
		return fmt.Errorf("error reading config file: %w", err)
	}

	v.Set("emulator.mappings", emuConfig.Mappings)
	if err := v.WriteConfigAs(configFile); err != nil {
		return fmt.Errorf("failed to write updated config file: %w", err)
	}

	logger.Printf("Saved updated emulator mappings to config file: %s", configFile)

	return nil
}
